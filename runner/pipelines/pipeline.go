package pipelines

import (
	"errors"
	"fmt"
	"log/slog"
	"os"
	"os/exec"
	"strings"
)

// ExecuteStep executes a single step
func ExecuteStep(step Step, variables map[string]string) error {
	slog.Info("Executing step: " + step.Name)
	command := SubstituteVariables(step.Run, variables)
	cmd := exec.Command("sh", "-c", command)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return errors.New("error executing step " + step.Name + ": " + err.Error() + ", output: " + string(output))
	}
	slog.Info("Output: " + string(output))
	return nil
}

// ExecuteJob executes all steps in a job
func ExecuteJob(job Job, variables map[string]string) error {
	slog.Info("Executing job: " + job.Name)
	for _, step := range job.Steps {
		err := ExecuteStep(step, variables)
		if err != nil {
			return err
		}
	}
	return nil
}

// SubstituteVariables substitutes variables in the command
func SubstituteVariables(command string, variables map[string]string) string {
	for key, value := range variables {
		placeholder := fmt.Sprintf("${%s}", key)
		command = strings.ReplaceAll(command, placeholder, value)
	}
	return command
}

// PrepareRun creates a _work directory which the job will use as context
func PrepareRun() {
	// TODO(spyrosmoux) create a unique dir for the run based on the unique build number (build number -> generated by the API)
	err := os.Mkdir("_work", 0755)
	if err != nil {
		slog.Error("Error creating temporary directory: " + err.Error())
	}

	err = os.Chdir("_work")
	if err != nil {
		slog.Error("Error switching context: " + err.Error())
	}
}

// CleanupRun deletes the '_work' directory and all its contents
func CleanupRun() {
	err := os.Chdir("../")
	if err != nil {
		slog.Error("Error switching context: " + err.Error())
	}

	err = os.RemoveAll("_work")
	if err != nil {
		slog.Error("Error removing temporary directory '_work': " + err.Error())
	}
	slog.Info("Temporary directory '_work' removed successfully")
}

// RunPipeline prepares, executes and cleans-up a run
func RunPipeline(pipeline Pipeline) error {
	PrepareRun()

	for _, job := range pipeline.Jobs {
		slog.Info("Running job: " + job.Name)
		err := ExecuteJob(job, pipeline.Variables)
		if err != nil {
			CleanupRun()
			slog.Error("Error executing job: " + err.Error())
			return err
		}
	}

	CleanupRun()

	return nil
}
