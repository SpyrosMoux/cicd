package pipelines

import (
	"bufio"
	"context"
	"fmt"
	"io"
	"os"
	"os/exec"
	"strings"
	"time"

	"github.com/sirupsen/logrus"
	"github.com/spyrosmoux/cicd/common/dto"
	"github.com/spyrosmoux/cicd/common/queue"
	"github.com/spyrosmoux/cicd/runner/dirmanagement"
	"github.com/spyrosmoux/cicd/runner/git"
)

type service struct {
	logger    *logrus.Entry
	gitClient git.GitClient
}

func NewService(logger *logrus.Entry, gitClient git.GitClient) Service {
	return &service{
		logger:    logger,
		gitClient: gitClient,
	}
}

// PrepareRun clones the repo into the source directory
func (svc *service) PrepareRun(repoMeta dto.Metadata) error {
	// TODO(@SpyrosMoux) create a unique dir for the run based on the unique build number (build number -> generated by the API)
	err := svc.gitClient.CloneRepo(repoMeta, dirmanagement.GlobalDM.GetSourceDir())
	if err != nil {
		return err
	}

	_, err = dirmanagement.GlobalDM.SetCurrentDir(dirmanagement.GlobalDM.GetSourceDir() + "/" + repoMeta.Repository)
	if err != nil {
		return err
	}

	err = svc.gitClient.CheckoutBranch(repoMeta.Branch)
	if err != nil {
		return err
	}

	_, err = dirmanagement.GlobalDM.SetCurrentDir(dirmanagement.GlobalDM.GetWorkDir())
	if err != nil {
		return err
	}

	return nil
}

// CleanupRun deletes the '_work' directory and all its contents
func (svc *service) CleanupRun() error {
	pathToRemove, err := dirmanagement.GlobalDM.SetCurrentDir(dirmanagement.GlobalDM.GetWorkDir())
	if err != nil {
		return err
	}

	err = os.RemoveAll(pathToRemove)
	if err != nil {
		pipelineRunId := svc.logger.Context.Value("pipelineRunId").(string)
		queue.PublishLog(pipelineRunId, dto.LogEntryDto{
			RunId:     pipelineRunId,
			Timestamp: time.Now().UTC().String(),
			LogLevel:  "ERROR",
			Message:   fmt.Sprintf("failed to remove temporary directory err=%v", err),
		})
		return err
	}

	_, err = dirmanagement.GlobalDM.SetCurrentDir(dirmanagement.RUNNER_DIR)
	if err != nil {
		return err
	}

	pipelineRunId := svc.logger.Context.Value("pipelineRunId").(string)
	queue.PublishLog(pipelineRunId, dto.LogEntryDto{
		RunId:     pipelineRunId,
		Timestamp: time.Now().UTC().String(),
		LogLevel:  "ERROR",
		Message:   fmt.Sprintf("temporary directory removed successfully directory=%s", pathToRemove),
	})
	return nil
}

// ExecuteStep executes a single step
func (svc *service) ExecuteStep(ctx context.Context, step Step, variables map[string]string) error {
	queue.PublishLog(ctx.Value("pipelineRunId").(string), dto.LogEntryDto{
		RunId:     ctx.Value("pipelineRunId").(string),
		Timestamp: time.Now().UTC().String(),
		LogLevel:  "INFO",
		Message:   fmt.Sprintf("executing step step=%s", step.Name),
	})

	command := svc.SubstituteUserVariables(step.Run, variables)
	cmd := exec.Command("sh", "-c", command)

	stdout, _ := cmd.StdoutPipe()
	stderr, _ := cmd.StderrPipe()

	if err := cmd.Start(); err != nil {
		queue.PublishLog(ctx.Value("pipelineRunId").(string), dto.LogEntryDto{
			RunId:     ctx.Value("pipelineRunId").(string),
			Timestamp: time.Now().UTC().String(),
			LogLevel:  "ERROR",
			Message:   fmt.Sprintf("failed to start step step=%s", step.Name),
		})
		return err
	}

	go streamOutput(stdout, dto.LogEntryDto{
		RunId:     ctx.Value("pipelineRunId").(string),
		Timestamp: time.Now().UTC().String(),
		LogLevel:  "INFO",
		Message:   "",
	})
	go streamOutput(stderr, dto.LogEntryDto{
		RunId:     ctx.Value("pipelineRunId").(string),
		Timestamp: time.Now().UTC().String(),
		LogLevel:  "ERROR",
		Message:   "",
	})

	if err := cmd.Wait(); err != nil {
		queue.PublishLog(ctx.Value("pipelineRunId").(string), dto.LogEntryDto{
			RunId:     ctx.Value("pipelineRunId").(string),
			Timestamp: time.Now().UTC().String(),
			LogLevel:  "ERROR",
			Message:   fmt.Sprintf("failed executing step step=%s", step.Name),
		})
		return fmt.Errorf("failure executing step step=%s, err=%s", step.Name, err.Error())
	}

	queue.PublishLog(ctx.Value("pipelineRunId").(string), dto.LogEntryDto{
		RunId:     ctx.Value("pipelineRunId").(string),
		Timestamp: time.Now().UTC().String(),
		LogLevel:  "INFO",
		Message:   fmt.Sprintf("step completed successfully step=%s", step.Name),
	})
	return nil
}

// ExecuteJob executes all steps in a job
func (svc *service) ExecuteJob(ctx context.Context, job Job, variables map[string]string) error {
	queue.PublishLog(ctx.Value("pipelineRunId").(string), dto.LogEntryDto{
		RunId:     ctx.Value("pipelineRunId").(string),
		Timestamp: time.Now().UTC().String(),
		LogLevel:  "INFO",
		Message:   fmt.Sprintf("executing job %s", job.Name),
	})
	for _, step := range job.Steps {
		err := svc.ExecuteStep(ctx, step, variables)
		if err != nil {
			return err
		}
	}
	return nil
}

// RunPipeline prepares, executes and cleans-up a run
func (svc *service) RunPipeline(ctx context.Context, pipeline Pipeline, runMetadata dto.Metadata) error {
	defer func(svc *service) {
		err := svc.CleanupRun()
		if err != nil {
			queue.PublishLog(ctx.Value("pipelineRunId").(string), dto.LogEntryDto{
				RunId:     ctx.Value("pipelineRunId").(string),
				Timestamp: time.Now().UTC().String(),
				LogLevel:  "ERROR",
				Message:   fmt.Sprintf("err=%v", err),
			})
		}
	}(svc)

	err := svc.PrepareRun(runMetadata)
	if err != nil {
		return err
	}

	svc.SubstitutePredefinedVariables(pipeline, PredefinedVars)

	for _, job := range pipeline.Jobs {
		queue.PublishLog(ctx.Value("pipelineRunId").(string), dto.LogEntryDto{
			RunId:     ctx.Value("pipelineRunId").(string),
			Timestamp: time.Now().UTC().String(),
			LogLevel:  "INFO",
			Message:   fmt.Sprintf("running job job=%s", job.Name),
		})

		err = svc.ExecuteJob(ctx, job, pipeline.Variables)
		if err != nil {
			queue.PublishLog(ctx.Value("pipelineRunId").(string), dto.LogEntryDto{
				RunId:     ctx.Value("pipelineRunId").(string),
				Timestamp: time.Now().UTC().String(),
				LogLevel:  "ERROR",
				Message:   fmt.Sprintf("failed to run job job=%s", job.Name),
			})
			return err
		}
	}

	return nil
}

// SubstituteUserVariables substitutes user defined variables for a specific command
func (svc *service) SubstituteUserVariables(command string, variables map[string]string) string {
	for key, value := range variables {
		placeholder := fmt.Sprintf("${%s}", key)
		command = strings.ReplaceAll(command, placeholder, value)
	}
	return command
}

// SubstitutePredefinedVariables substitutes all predefined variables used in the pipeline
func (svc *service) SubstitutePredefinedVariables(pipeline Pipeline, predefinedVariables map[string]string) Pipeline {
	for i, job := range pipeline.Jobs {
		for j, step := range job.Steps {
			pipeline.Jobs[i].Steps[j].Run = replaceVariables(step.Run, predefinedVariables)
		}
	}
	return pipeline
}

func replaceVariables(input string, variables map[string]string) string {
	for key, value := range variables {
		input = strings.ReplaceAll(input, key, value)
	}
	return input
}

func streamOutput(pipe io.ReadCloser, logEntryDto dto.LogEntryDto) {
	scanner := bufio.NewScanner(pipe)
	for scanner.Scan() {
		logEntryDto.Message = scanner.Text()
		queue.PublishLog(logEntryDto.RunId, logEntryDto)
	}
}
