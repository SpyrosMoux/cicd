package pipelines

import (
	"errors"
	"fmt"
	"github.com/spyrosmoux/cicd/common/dto"
	"github.com/spyrosmoux/cicd/runner/dirmanagement"
	"github.com/spyrosmoux/cicd/runner/git"
	"log/slog"
	"os"
	"os/exec"
	"strings"
)

type service struct{}

func NewService() Service {
	return &service{}
}

// PrepareRun creates a _work directory which the job will use as context
// It also clones the given repo from the metadata
func (svc *service) PrepareRun(repoMeta dto.Metadata) error {
	// TODO(@SpyrosMoux) create a unique dir for the run based on the unique build number (build number -> generated by the API)
	err := dirmanagement.GlobalDM.CreateDirectory(dirmanagement.WORK_DIR)
	if err != nil {
		return err
	}

	_, err = dirmanagement.GlobalDM.SetWorkDir(dirmanagement.WORK_DIR)
	if err != nil {
		return err
	}

	_, err = dirmanagement.GlobalDM.SetCurrentDir(dirmanagement.GlobalDM.GetWorkDir())
	if err != nil {
		return err
	}

	err = dirmanagement.GlobalDM.CreateDirectory(dirmanagement.ARTIFACT_DIR)
	if err != nil {
		return err
	}

	_, err = dirmanagement.GlobalDM.SetArtifactDir(dirmanagement.ARTIFACT_DIR)
	if err != nil {
		return err
	}

	err = dirmanagement.GlobalDM.CreateDirectory(dirmanagement.SOURCE_DIR)
	if err != nil {
		return err
	}

	_, err = dirmanagement.GlobalDM.SetSourceDir(dirmanagement.SOURCE_DIR)
	if err != nil {
		return err
	}

	err = git.CloneRepo(repoMeta, dirmanagement.GlobalDM.GetSourceDir())
	if err != nil {
		return err
	}

	_, err = dirmanagement.GlobalDM.SetCurrentDir(dirmanagement.GlobalDM.GetSourceDir() + "/" + repoMeta.Repository)
	if err != nil {
		return err
	}

	err = git.CheckoutBranch(repoMeta.Branch)
	if err != nil {
		return err
	}

	_, err = dirmanagement.GlobalDM.SetCurrentDir(dirmanagement.GlobalDM.GetWorkDir())
	if err != nil {
		return err
	}

	return nil
}

// CleanupRun deletes the '_work' directory and all its contents
func (svc *service) CleanupRun() error {
	pathToRemove, err := dirmanagement.GlobalDM.SetCurrentDir(dirmanagement.GlobalDM.GetWorkDir())
	if err != nil {
		return err
	}

	err = os.RemoveAll(pathToRemove)
	if err != nil {
		slog.Error("Error removing temporary directory " + pathToRemove + ": " + err.Error())
		return err
	}

	_, err = dirmanagement.GlobalDM.SetCurrentDir(dirmanagement.RUNNER_DIR)
	if err != nil {
		return err
	}

	slog.Info("Temporary directory " + pathToRemove + " removed successfully")
	return nil
}

// ExecuteStep executes a single step
func (svc *service) ExecuteStep(step Step, variables map[string]string) error {
	slog.Info("Executing step: " + step.Name)
	command := svc.SubstituteVariables(step.Run, variables)
	cmd := exec.Command("sh", "-c", command)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return errors.New("error executing step " + step.Name + ": " + err.Error() + ", output: " + string(output))
	}
	slog.Info("Output: " + string(output))
	return nil
}

// ExecuteJob executes all steps in a job
func (svc *service) ExecuteJob(job Job, variables map[string]string) error {
	slog.Info("Executing job: " + job.Name)
	for _, step := range job.Steps {
		err := svc.ExecuteStep(step, variables)
		if err != nil {
			return err
		}
	}
	return nil
}

// SubstituteVariables substitutes variables in the command
func (svc *service) SubstituteVariables(command string, variables map[string]string) string {
	for key, value := range variables {
		placeholder := fmt.Sprintf("${%s}", key)
		command = strings.ReplaceAll(command, placeholder, value)
	}
	return command
}

// RunPipeline prepares, executes and cleans-up a run
func (svc *service) RunPipeline(pipeline Pipeline, runMetadata dto.Metadata) error {
	defer func(svc *service) {
		err := svc.CleanupRun()
		if err != nil {
			slog.Error(err.Error())
		}
	}(svc)

	err := svc.PrepareRun(runMetadata)
	if err != nil {
		return err
	}

	for _, job := range pipeline.Jobs {
		slog.Info("Running job: " + job.Name)
		err := svc.ExecuteJob(job, pipeline.Variables)
		if err != nil {
			err2 := svc.CleanupRun()
			if err2 != nil {
				return err2
			}
			slog.Error("Error executing job: " + err.Error())
			return err
		}
	}

	return nil
}
